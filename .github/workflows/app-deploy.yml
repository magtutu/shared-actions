name: Reusable Deploy Workflow

env:
  AWS_ACCOUNT_ID: "435837797149"

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      app-name:
        required: true
        type: string
    outputs:
      deployment-url:
        value: ${{ jobs.deploy.outputs.url }}

jobs:
  deploy:
    name: Deploy to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    # This is key: the environment controls access to secrets and can require approvals
    environment: 
      name: ${{ inputs.environment }}
      url: ${{ steps.deploy.outputs.url }}
    
    # Required for OIDC authentication with AWS
    permissions:
      id-token: write
    
    outputs:
      url: ${{ steps.deploy.outputs.url }}
    
    steps:      
      - name: Check secret and variable access
        uses: ./check-vars
        env:
          DEPLOY_TOKEN: ${{ secrets.DEPLOY_TOKEN }}
          DEPLOY_INFO: ${{ vars.DEPLOY_INFO }}
        with:
          context-name: app-deploy job (${{ inputs.environment }} environment)
      
      - name: Extract calling repository name
        id: repo-info
        run: |
          # GitHub provides the calling workflow in GITHUB_WORKFLOW_REF
          # Format: owner/repo/.github/workflows/workflow.yml@ref
          WORKFLOW_REF="${{ github.workflow_ref }}"
          echo "Workflow ref: $WORKFLOW_REF"
          
          # Extract repo name from the workflow ref
          # For reusable workflows, we need to look at the event
          CALLING_REPO="${{ github.event.repository.name }}"
          
          # If this is a workflow_call, the repository is the calling repo
          if [ "${{ github.event_name }}" = workflow_call ]; then
            # The repository context shows the repo where workflow is defined (shared-actions)
            # But we can extract from workflow_ref which shows the caller
            echo "This is a reusable workflow call"
            # For now, use the app-name input as the repo identifier
            CALLING_REPO="${{ inputs.app-name }}"
          fi
          
          echo "calling-repo=$CALLING_REPO" >> $GITHUB_OUTPUT
          echo "role-name=deployment-role-$CALLING_REPO" >> $GITHUB_OUTPUT
          echo "Calling repo: $CALLING_REPO"
          echo "Role to assume: deployment-role-$CALLING_REPO"
          
          # Debug OIDC token claims
          echo "================================"
          echo "GitHub Context for OIDC:"
          echo "  repository: ${{ github.repository }}"
          echo "  repository_owner: ${{ github.repository_owner }}"
          echo "  ref: ${{ github.ref }}"
          echo "  sha: ${{ github.sha }}"
          echo "  workflow: ${{ github.workflow }}"
          echo "  event_name: ${{ github.event_name }}"
          echo "  actor: ${{ github.actor }}"
          echo "================================"
      
      - name: Debug role ARN
        run: |
          echo "ðŸ” Role ARN that will be assumed:"
          echo "arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/${{ steps.repo-info.outputs.role-name }}"
          echo ""
          echo "Expected trust policy sub claim should be:"
          echo "repo:${{ github.repository }}:ref:${{ github.ref }}"
          echo ""
          echo "ðŸ” Checking OIDC token (this will be used by AWS):"
          echo "The actual sub claim in the OIDC token will be checked by AWS"
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/${{ steps.repo-info.outputs.role-name }}
          aws-region: us-east-1
          role-session-name: github-actions-${{ inputs.app-name }}-${{ inputs.environment }}
        continue-on-error: true
        id: aws-creds
      
      - name: Debug AWS credential failure
        if: steps.aws-creds.outcome == 'failure'
        run: |
          echo "âŒ Failed to assume role"
          echo "Role ARN: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/${{ steps.repo-info.outputs.role-name }}"
          echo "This usually means the trust policy doesn't match the OIDC token claims"
          echo ""
          echo "Trust policy should have:"
          echo '  "token.actions.githubusercontent.com:sub": "repo:${{ github.repository }}:ref:${{ github.ref }}"'
          exit 1
      
      - name: Print environment variables after AWS config
        run: |
          echo "ðŸ” Environment Variables after AWS credentials configured:"
          echo "================================"
          env | sort
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Deploy application
        id: deploy
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ inputs.app-name }}
          SERVICE_NAME: ${{ inputs.app-name }}-service
          CLUSTER_NAME: ${{ secrets.ECS_CLUSTER_NAME }}
          CALLING_REPO: ${{ steps.repo-info.outputs.calling-repo }}
          ROLE_NAME: ${{ steps.repo-info.outputs.role-name }}
        run: |
          echo "ðŸš€ Deploying ${{ inputs.app-name }} to ${{ inputs.environment }}..."
          echo "ï¿½ Using role: $ROLE_NAME"
          echo "ï¿½ Carlling repo: $CALLING_REPO"
          echo "ðŸŽ¯ Target service: $SERVICE_NAME"
          
          # Verify AWS credentials
          echo "Verifying AWS credentials..."
          aws sts get-caller-identity
          
          # In a real deployment, you would:
          # 1. Build and push Docker image
          # echo "Building Docker image..."
          # docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
          # docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          # 2. Update ECS service
          # echo "Updating ECS service..."
          # aws ecs update-service \
          #   --cluster $CLUSTER_NAME \
          #   --service $SERVICE_NAME \
          #   --force-new-deployment
          
          # For now, simulate deployment
          echo "Simulating deployment..."
          sleep 2
          
          # Set output URL based on environment
          if [ "${{ inputs.environment }}" == production ]; then
            echo "url=https://${{ inputs.app-name }}.example.com" >> $GITHUB_OUTPUT
          else
            echo "url=https://${{ inputs.environment }}-${{ inputs.app-name }}.example.com" >> $GITHUB_OUTPUT
          fi
          
          echo "âœ… Deployment successful!"
      
      - name: Post-deployment verification
        run: |
          echo "Verifying deployment at ${{ steps.deploy.outputs.url }}"
          echo "Environment: ${{ inputs.environment }}"
